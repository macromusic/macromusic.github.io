VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "CShtNumAry"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
'Includes PfixGetSheetRangeData
'Includes PfixHVMatchString
'Includes PfixArrayRowSplitString

Option Explicit
Option Base 1

'◆ClassProc名_シート上の指定範囲またはデータ全範囲から数値データ配列を取得する
'Rev.001
  
'//モジュールメモリ
  Private Const meMstrMdlName As String = "CShtNumAry"
  
'//PropertyGet_出力制御信号
  Private myXbisCmpltFlag As Boolean
  
'//PropertyGet_出力データ
  Private Lc As Long
  Private myXlonNumRowCnt As Long, myXlonNumColCnt As Long, myZdouNumData() As Double
  Private myXstrHdrRowCnt As Long, myXstrHdrColCnt As Long, myZstrHdr() As String
  
'//PropertySetLet_入力データ
  Private myXobjSheet As Object, myXobjFrstCell As Object, myXobjLastCell As Object
  
  Private myXstrIfCndtn As String, myXbisInStrOptn As Boolean
  Private myXlonOfstRows As Long, myXlonOfstCols As Long
  
  Private myXlonNumRows As Long, myXlonNumCols As Long
  
'//モジュール内変数_制御信号
  Private myXbisExitFlag As Boolean
  
'//モジュール内変数_データ
  Private myXlonRowCnt As Long, myXlonColCnt As Long, myZstrOrgData() As String

'iniP_モジュール内変数を初期化する
Private Sub initializeModuleVariables()
    myXbisExitFlag = False
    
    myXlonRowCnt = Empty: myXlonColCnt = Empty
    Erase myZstrOrgData
End Sub

'-----------------------------------------------------------------------------------------------

Public Property Get getOptnBase() As Long
  Dim myZlonTmp(1) As Long, L As Long: L = LBound(myZlonTmp)
    getOptnBase = L
End Property

Public Property Get getCmpltFlag() As Boolean
    getCmpltFlag = myXbisCmpltFlag
End Property

Public Property Get getNumRowCnt() As Long
    getNumRowCnt = myXlonNumRowCnt
End Property

Public Property Get getNumColCnt() As Long
    getNumColCnt = myXlonNumColCnt
End Property

Public Property Get getNumDataAry(ByVal i As Long, ByVal j As Long) As Double
    getNumDataAry = myZdouNumData(i, j)
'myZdouNumData(i, j) : 取得データ
End Property

Public Property Get getHdrRowCnt() As Long
    getHdrRowCnt = myXstrHdrRowCnt
End Property

Public Property Get getHdrColCnt() As Long
    getHdrColCnt = myXstrHdrColCnt
End Property

Public Property Get getHdrAry(ByVal i As Long, ByVal j As Long) As String
    getHdrAry = myZstrHdr(i, j)
'myZstrHdr(i, j) : ヘッダー内容
End Property

'iniP_出力変数を初期化する
Private Sub initializeOutputVariables()
    myXbisCmpltFlag = False
    
    myXlonNumRowCnt = Empty: myXlonNumColCnt = Empty: Erase myZdouNumData
    myXstrHdrRowCnt = Empty: myXstrHdrColCnt = Empty: Erase myZstrHdr
End Sub

'-----------------------------------------------------------------------------------------------

Public Property Set setSheet(ByVal RHS As Object)
    Set myXobjSheet = RHS
End Property

Public Property Set setFrstCell(ByVal RHS As Object)
    Set myXobjFrstCell = RHS
End Property

Public Property Set setLastCell(ByVal RHS As Object)
    Set myXobjLastCell = RHS
End Property

Public Property Let letIfCndtn(ByVal RHS As String)
    myXstrIfCndtn = RHS
'myXstrIfCndtn : 数値データの最初のデータ位置の検索条件
End Property

Public Property Let letInStrOptn(ByVal RHS As Boolean)
    myXbisInStrOptn = RHS
'myXbisInStrOptn = False : 指定文字列と一致する条件で検索する
'myXbisInStrOptn = True  : 指定文字列を含む条件で検索する
End Property

Public Property Let letOfstRows(ByVal RHS As Long)
    myXlonOfstRows = RHS
'myXlonOfstRows : 検索位置から数値データの最初のデータ位置のオフセット行数
End Property

Public Property Let letOfstCols(ByVal RHS As Long)
    myXlonOfstCols = RHS
'myXlonOfstCols : 検索位置から数値データの最初のデータ位置のオフセット列数
End Property

Public Property Let letNumRows(ByVal RHS As Long)
    myXlonNumRows = RHS
'myXlonNumRows : 数値データの取得行数
End Property

Public Property Let letNumCols(ByVal RHS As Long)
    myXlonNumCols = RHS
'myXlonNumCols : 数値データの取得列数
End Property

'checkP_入力変数内容を確認する
Private Sub checkInputVariables()
    myXbisExitFlag = False
    
    If myXobjSheet Is Nothing Then GoTo ExitPath
    On Error GoTo ExitPath
  Dim myXvarTmp As Variant: myXvarTmp = myXobjSheet.Cells(1, 1).Value
    On Error GoTo 0
    
    Exit Sub
ExitPath:
    myXbisExitFlag = True
End Sub

'-----------------------------------------------------------------------------------------------

'PublicP_
Public Sub exeProc()
    Call ctrProc
End Sub

'CtrlP_
Private Sub ctrProc()
    Call initializeOutputVariables
    Call initializeModuleVariables
    Call checkInputVariables: If myXbisExitFlag = True Then GoTo ExitPath
'    Debug.Print "PassFlag: " & meMstrMdlName & "1"     'PassFlag
  
'//シート上の指定範囲またはデータ全範囲のデータを配列に取込む
    Call PfixGetSheetRangeData( _
            myXlonRowCnt, myXlonColCnt, myZstrOrgData, _
            myXobjSheet, myXobjFrstCell, myXobjLastCell)
    If myXlonRowCnt <= 0 Or myXlonColCnt <= 0 Then GoTo ExitPath
'    Debug.Print "PassFlag: " & meMstrMdlName & "2"     'PassFlag

'//2次元配列で文字列を検索して数値データの最初のデータ位置を取得
  Dim myXlonSrchRow As Long, myXlonSrchCol As Long
    Call PfixHVMatchString(myXlonSrchRow, myXlonSrchCol, _
            myXstrIfCndtn, myZstrOrgData, myXbisInStrOptn)
'    Debug.Print "PassFlag: " & meMstrMdlName & "3"     'PassFlag

  Dim L1 As Long, U1 As Long, L2 As Long, U2 As Long
    L1 = LBound(myZstrOrgData, 1): U1 = UBound(myZstrOrgData, 1)
    L2 = LBound(myZstrOrgData, 2): U2 = UBound(myZstrOrgData, 2)
    
'//取得する第一行と第一列を設定
  Dim myXlonNumBgnRow As Long, myXlonNumBgnCol As Long
    If myXlonSrchRow < L1 Then
        myXlonNumBgnRow = L1
    Else
        myXlonNumBgnRow = myXlonSrchRow + myXlonOfstRows
        If myXlonNumBgnRow < L1 Then myXlonNumBgnRow = L1
    End If
    If myXlonSrchCol < L2 Then
        myXlonNumBgnCol = L2
    Else
        myXlonNumBgnCol = myXlonSrchCol + myXlonOfstCols
        If myXlonNumBgnCol < L2 Then myXlonNumBgnCol = L2
    End If
    
'//数値データを取得する範囲を設定
  Dim myXlonNumEndRow As Long, myXlonNumEndCol As Long
    myXlonNumEndRow = myXlonNumBgnRow + myXlonNumRows - 1
    myXlonNumEndCol = myXlonNumBgnCol + myXlonNumCols - 1
    If myXlonNumEndRow > U1 Or myXlonNumEndRow < myXlonNumBgnRow Then _
        myXlonNumEndRow = U1
    If myXlonNumEndCol > U2 Or myXlonNumEndCol < myXlonNumBgnCol Then _
        myXlonNumEndCol = U2
    
'//2次元配列から数値データ範囲のデータ配列を取得
    myXlonNumRowCnt = myXlonNumEndRow - myXlonNumBgnRow + 1
    myXlonNumColCnt = myXlonNumEndCol - myXlonNumBgnCol + 1
    ReDim myZdouNumData(myXlonNumRowCnt, myXlonNumColCnt) As Double
    
  Dim i As Long, j As Long, m As Long, n As Long: m = 0: n = 0
    On Error Resume Next
    For j = myXlonNumBgnCol To myXlonNumEndCol
        n = n + 1
        m = 0
        For i = myXlonNumBgnRow To myXlonNumEndRow
            m = m + 1
            myZdouNumData(m, n) = CDbl(myZstrOrgData(i, j))
        Next i
    Next j
    On Error GoTo 0
    If m <> myXlonNumRowCnt Or n <> myXlonNumColCnt Then GoTo ExitPath
'    Debug.Print "PassFlag: " & meMstrMdlName & "4"     'PassFlag

'//ヘッダー内容を取得
  Dim myXlonSpltRow As Long: myXlonSpltRow = myXlonNumBgnRow
  Dim myXlonDwnRowCnt As Long, myZstrDwn() As String
    Call PfixArrayRowSplitString( _
            myXstrHdrRowCnt, myZstrHdr, myXlonDwnRowCnt, myZstrDwn, _
            myZstrOrgData, myXlonSpltRow)
    If myXstrHdrRowCnt > 0 Then myXstrHdrColCnt = myXlonColCnt
    Erase myZstrDwn
'    Debug.Print "PassFlag: " & meMstrMdlName & "5"     'PassFlag
    
    myXbisCmpltFlag = True
ExitPath:
    Call initializeModuleVariables
End Sub

'===============================================================================================

 '定型Ｐ_シート上の指定範囲またはデータ全範囲のデータを配列に取込む
Private Sub PfixGetSheetRangeData( _
            myXlonRowCnt As Long, myXlonColCnt As Long, myZstrShtData() As String, _
            ByVal myXobjSheet As Object, _
            ByVal myXobjFrstCell As Object, ByVal myXobjLastCell As Object)
'myZstrShtData(i, j) : データ
    myXlonRowCnt = Empty: myXlonColCnt = Empty: Erase myZstrShtData
    If myXobjSheet Is Nothing Then Exit Sub
'//シート上の指定範囲をオブジェクト配列に取込む
  Dim myXobjShtRng As Object
    If myXobjFrstCell Is Nothing Then Set myXobjFrstCell = myXobjSheet.Cells(1, 1)
    If myXobjLastCell Is Nothing Then _
        Set myXobjLastCell = myXobjSheet.Cells.SpecialCells(xlCellTypeLastCell)
    Set myXobjShtRng = myXobjSheet.Range(myXobjFrstCell, myXobjLastCell)
    myXlonRowCnt = myXobjShtRng.Rows.Count
    myXlonColCnt = myXobjShtRng.Columns.Count
    If myXlonRowCnt <= 0 Or myXlonColCnt <= 0 Then Exit Sub
'//オブジェクト配列からデータを取得
  Dim myZlonTmp(1) As Long, L As Long: L = LBound(myZlonTmp)
  Dim myZvarRngData As Variant, i As Long, j As Long
    i = myXlonRowCnt - (1 - L): j = myXlonColCnt - (1 - L)
    ReDim myZstrShtData(i, j) As String
    myZvarRngData = myXobjShtRng.Value
    On Error Resume Next
    If myXlonRowCnt * myXlonColCnt = 1 Then
        myZstrShtData(L, L) = myZvarRngData
    Else
        For j = LBound(myZvarRngData, 2) To UBound(myZvarRngData, 2)
            For i = LBound(myZvarRngData, 1) To UBound(myZvarRngData, 1)
                myZstrShtData(i, j) = myZvarRngData(i, j)
            Next i
        Next j
    End If
    On Error GoTo 0
    Set myXobjShtRng = Nothing: myZvarRngData = Empty
End Sub

 '定型Ｐ_2次元配列で文字列を検索して最初のデータ位置を取得する
Private Sub PfixHVMatchString(myXlonRow As Long, myXlonCol As Long, _
            ByVal myXstrIfCndtn As String, ByRef myZstrOrgData() As String, _
            Optional ByVal coXbisInStrOptn As Boolean = False)
'myZstrOrgData(i, j) : 元データ配列
'coXbisInStrOptn = False : 指定文字列と一致する条件
'coXbisInStrOptn = True  : 指定文字列とを含む条件
    myXlonRow = Empty: myXlonCol = Empty
    If myXstrIfCndtn = "" Then Exit Sub
  Dim myXstrTmp As String, L As Long
    On Error GoTo ExitPath
    L = LBound(myZstrOrgData, 1): myXstrTmp = myZstrOrgData(L, L)
    On Error GoTo 0
  Dim i As Long, j As Long, r As Long, c As Long: r = L - 1: c = L - 1
    If coXbisInStrOptn = True Then
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            For i = LBound(myZstrOrgData, 1) To UBound(myZstrOrgData, 1)
                myXstrTmp = myZstrOrgData(i, j)
                If InStr(myXstrTmp, myXstrIfCndtn) > 0 Then
                    r = i: c = j: GoTo JumpPath
                End If
            Next i
        Next j
    Else
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            For i = LBound(myZstrOrgData, 1) To UBound(myZstrOrgData, 1)
                myXstrTmp = myZstrOrgData(i, j)
                If myXstrTmp = myXstrIfCndtn Then
                    r = i: c = j: GoTo JumpPath
                End If
            Next i
        Next j
    End If
JumpPath:
    myXlonRow = r: myXlonCol = c
ExitPath:
End Sub

 '定型Ｐ_2次元配列を指定行で2個の配列に分割する
Private Sub PfixArrayRowSplitString( _
            myXlonUpRowCnt As Long, myZstrUp() As String, _
            myXlonDwnRowCnt As Long, myZstrDwn() As String, _
            ByRef myZstrOrgData() As String, ByVal myXlonSpltRow As Long)
'myZstrUp(i, j)  : 分割後の上側データ配列
'myZstrDwn(i, j) : 分割後の下側データ配列
'myZstrOrgData(i, j) : 元データ配列
'myXlonSpltRow : 分割する行番号を指定(指定行以下を分割)
    myXlonUpRowCnt = Empty: Erase myZstrUp
    myXlonDwnRowCnt = Empty: Erase myZstrDwn
  Dim myXstrTmp As String, L As Long
    On Error GoTo ExitPath
    L = LBound(myZstrOrgData, 1): myXstrTmp = myZstrOrgData(L, L)
    On Error GoTo 0
    If myXlonSpltRow < LBound(myZstrOrgData, 1) + 1 _
        Or myXlonSpltRow > UBound(myZstrOrgData, 1) Then Exit Sub
  Dim i As Long, j As Long, m As Long, n As Long: m = L - 1: n = L - 1
    myXlonUpRowCnt = myXlonSpltRow - LBound(myZstrOrgData, 1)
    myXlonDwnRowCnt = UBound(myZstrOrgData, 1) - myXlonSpltRow + 1
    j = UBound(myZstrOrgData, 2)
    i = myXlonUpRowCnt - (1 - L): ReDim myZstrUp(i, j) As String
    i = myXlonDwnRowCnt - (1 - L): ReDim myZstrDwn(i, j) As String
    For i = LBound(myZstrOrgData, 1) To myXlonSpltRow - 1
        m = m + 1
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            myZstrUp(m, j) = myZstrOrgData(i, j)
        Next j
    Next i
    For i = myXlonSpltRow To UBound(myZstrOrgData, 1)
        n = n + 1
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            myZstrDwn(n, j) = myZstrOrgData(i, j)
        Next j
    Next i
ExitPath:
End Sub

'DummyＰ_
Private Sub CsubDummy()
End Sub

'===============================================================================================

''◆ClassProc名_シート上の指定範囲またはデータ全範囲から数値データ配列を取得する
'Private Sub instCShtNumAry()
'  Dim Lc As Long
'  Dim myXbisCmpltFlag As Boolean
'  Dim myXlonNumRowCnt As Long, myXlonNumColCnt As Long, myZdouNumData() As Double
'  Dim myXstrHdrRowCnt As Long, myXstrHdrColCnt As Long, myZstrHdr() As String
''//クラス内変数への入力
'  Dim myXobjSheet As Object, myXobjFrstCell As Object, myXobjLastCell As Object
'    Set myXobjSheet = ActiveSheet
'  Dim myXstrIfCndtn As String
'    'myXstrIfCndtn : 数値データの最初のデータ位置の検索条件
'  Dim myXbisInStrOptn As Boolean
'    'myXbisInStrOptn = False : 指定文字列と一致する条件で検索する
'    'myXbisInStrOptn = True  : 指定文字列を含む条件で検索する
'  Dim myXlonOfstRows As Long, myXlonOfstCols As Long
'    'myXlonOfstRows : 検索位置から数値データの最初のデータ位置のオフセット行数
'    'myXlonOfstCols : 検索位置から数値データの最初のデータ位置のオフセット列数
'    myXstrIfCndtn = "No"
'    myXbisInStrOptn = False
'    myXlonOfstRows = 1
'    myXlonOfstCols = 0
'  Dim myXlonNumRows As Long, myXlonNumCols As Long
'    'myXlonNumRows : 数値データの取得行数
'    'myXlonNumCols : 数値データの取得列数
'    myXlonNumRows = 10
'    myXlonNumCols = 1
''//CShtNumAryクラスモジュールのインスタンス生成
'  Dim myZlonTmp(1) As Long, Lo As Long: Lo = LBound(myZlonTmp)
'  Dim i As Long, j As Long
'  Dim myXinsShtNumAry As CShtNumAry: Set myXinsShtNumAry = New CShtNumAry
'    With myXinsShtNumAry
'    '//クラス内変数への入力
'        Set .setSheet = myXobjSheet
'        Set .setFrstCell = myXobjFrstCell
'        Set .setLastCell = myXobjLastCell
'        .letIfCndtn = myXstrIfCndtn
'        .letInStrOptn = myXbisInStrOptn
'        .letOfstRows = myXlonOfstRows
'        .letOfstCols = myXlonOfstCols
'        .letNumRows = myXlonNumRows
'        .letNumCols = myXlonNumCols
'    '//クラス内プロシージャの実行とクラス内変数からの出力
'        .exeProc
'        myXbisCmpltFlag = .getCmpltFlag
'        myXlonNumRowCnt = .getNumRowCnt
'        myXlonNumColCnt = .getNumColCnt
'        If myXlonNumRowCnt <= 0 Or myXlonNumColCnt <= 0 Then GoTo JumpPath
'        i = myXlonNumRowCnt + Lo - 1: j = myXlonNumColCnt + Lo - 1
'        ReDim myZdouNumData(i, j) As Double
'        Lc = .getOptnBase
'        For j = 1 To myXlonNumColCnt
'            For i = 1 To myXlonNumRowCnt
'                myZdouNumData(i + Lo - 1, j + Lo - 1) = .getNumDataAry(i + Lc - 1, j + Lc - 1)
'            Next i
'        Next j
'        myXstrHdrRowCnt = .getHdrRowCnt
'        myXstrHdrColCnt = .getHdrColCnt
'        If myXstrHdrRowCnt <= 0 Or myXstrHdrColCnt <= 0 Then GoTo JumpPath
'        i = myXstrHdrRowCnt + Lo - 1: j = myXstrHdrColCnt + Lo - 1
'        ReDim myZstrHdr(i, j) As String
'        For j = 1 To myXstrHdrColCnt
'            For i = 1 To myXstrHdrRowCnt
'                myZstrHdr(i + Lo - 1, j + Lo - 1) = .getHdrAry(i + Lc - 1, j + Lc - 1)
'            Next i
'        Next j
'    End With
'JumpPath:
'    Set myXinsShtNumAry = Nothing
''    Call variablesOfCShtNumAry(myXlonNumRowCnt, myZdouNumData)  'Debug.Print
'ExitPath:
'End Sub
'Private Sub variablesOfCShtNumAry( _
'            ByVal myXlonDataCnt As Long, ByRef myZvarField As Variant)
''//CShtNumAryクラス内から出力した変数の内容確認
'    Debug.Print "データ数: " & myXlonDataCnt
'    If myXlonDataCnt <= 0 Then Exit Sub
'  Dim i As Long, j As Long
'    For i = LBound(myZvarField, 1) To UBound(myZvarField, 1)
'        For j = LBound(myZvarField, 2) To UBound(myZvarField, 2)
'            Debug.Print "データ" & i & "," & j & ": " & myZvarField(i, j)
'        Next j
'    Next i
'End Sub
