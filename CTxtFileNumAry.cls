VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "CTxtFileNumAry"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
'Includes CRdTxtNoOpn
'Includes PfixHVMatchString
'Includes PfixArrayRowSplitString

Option Explicit
Option Base 1

'◆ClassProc名_テキストファイル内から数値データ配列を取得する
'Rev.001
  
'//モジュールメモリ
  Private Const meMstrMdlName As String = "CTxtFileNumAry"
  
'//PropertyGet_出力制御信号
  Private myXbisCmpltFlag As Boolean
  
'//PropertyGet_出力データ
  Private Lc As Long
  Private myXlonNumRowCnt As Long, myXlonNumColCnt As Long, myZdouNumData() As Double
  Private myXstrHdrRowCnt As Long, myXstrHdrColCnt As Long, myZstrHdr() As String
  
'//PropertySetLet_入力データ
  Private myXstrFilePath As String
  Private myXlonBgn As Long, myXlonEnd As Long
  Private myXbisSpltOptn As Boolean, myXstrSpltChr As String
  
  Private myXstrIfCndtn As String, myXbisInStrOptn As Boolean
  Private myXlonOfstRows As Long, myXlonOfstCols As Long
  
  Private myXlonNumRows As Long, myXlonNumCols As Long
  
'//モジュール内変数_制御信号
  Private myXbisExitFlag As Boolean
  
'//モジュール内変数_データ
  Private myXstrDirPath As String, myXstrFileName As String, _
            myXstrBaseName As String, myXstrExtsn As String
  
  Private myXlonRowCnt As Long, myXlonColCnt As Long, myZstrOrgData() As String

'iniP_モジュール内変数を初期化する
Private Sub initializeModuleVariables()
    myXbisExitFlag = False
    
    myXstrDirPath = Empty: myXstrFileName = Empty
    myXstrBaseName = Empty: myXstrExtsn = Empty
    
    myXlonRowCnt = Empty: myXlonColCnt = Empty
    Erase myZstrOrgData
End Sub

'-----------------------------------------------------------------------------------------------

Public Property Get getOptnBase() As Long
  Dim myZlonTmp(1) As Long, L As Long: L = LBound(myZlonTmp)
    getOptnBase = L
End Property

Public Property Get getCmpltFlag() As Boolean
    getCmpltFlag = myXbisCmpltFlag
End Property

Public Property Get getNumRowCnt() As Long
    getNumRowCnt = myXlonNumRowCnt
End Property

Public Property Get getNumColCnt() As Long
    getNumColCnt = myXlonNumColCnt
End Property

Public Property Get getNumDataAry(ByVal i As Long, ByVal j As Long) As Double
    getNumDataAry = myZdouNumData(i, j)
'myZdouNumData(i, j) : 取得データ
End Property

Public Property Get getHdrRowCnt() As Long
    getHdrRowCnt = myXstrHdrRowCnt
End Property

Public Property Get getHdrColCnt() As Long
    getHdrColCnt = myXstrHdrColCnt
End Property

Public Property Get getHdrAry(ByVal i As Long, ByVal j As Long) As String
    getHdrAry = myZstrHdr(i, j)
'myZstrHdr(i, j) : ヘッダー内容
End Property

'iniP_出力変数を初期化する
Private Sub initializeOutputVariables()
    myXbisCmpltFlag = False
    
    myXlonNumRowCnt = Empty: myXlonNumColCnt = Empty: Erase myZdouNumData
    myXstrHdrRowCnt = Empty: myXstrHdrColCnt = Empty: Erase myZstrHdr
End Sub

'-----------------------------------------------------------------------------------------------

Public Property Let letFilePath(ByVal RHS As String)
    myXstrFilePath = RHS
End Property

Public Property Let letRdBgnEnd(ByVal i As Long, ByVal RHS As Long)
    Select Case i
        Case 1: myXlonBgn = RHS
        Case 2: myXlonEnd = RHS
    End Select
'letRdBgnEnd(1) : 最初のデータ位置
'letRdBgnEnd(2) : 最後のデータ位置
End Property

Public Property Let letSpltOptn(ByVal RHS As Boolean)
    myXbisSpltOptn = RHS
'myXbisSpltOptn = True  : 文字列を分割処理する
'myXbisSpltOptn = False : 文字列を分割処理しない
End Property

Public Property Let letSpltChr(ByVal RHS As String)
    myXstrSpltChr = RHS
End Property

Public Property Let letIfCndtn(ByVal RHS As String)
    myXstrIfCndtn = RHS
'myXstrIfCndtn : 数値データの最初のデータ位置の検索条件
End Property

Public Property Let letInStrOptn(ByVal RHS As Boolean)
    myXbisInStrOptn = RHS
'myXbisInStrOptn = False : 指定文字列と一致する条件で検索する
'myXbisInStrOptn = True  : 指定文字列を含む条件で検索する
End Property

Public Property Let letOfstRows(ByVal RHS As Long)
    myXlonOfstRows = RHS
'myXlonOfstRows : 検索位置から数値データの最初のデータ位置のオフセット行数
End Property

Public Property Let letOfstCols(ByVal RHS As Long)
    myXlonOfstCols = RHS
'myXlonOfstCols : 検索位置から数値データの最初のデータ位置のオフセット列数
End Property

Public Property Let letNumRows(ByVal RHS As Long)
    myXlonNumRows = RHS
'myXlonNumRows : 数値データの取得行数
End Property

Public Property Let letNumCols(ByVal RHS As Long)
    myXlonNumCols = RHS
'myXlonNumCols : 数値データの取得列数
End Property

'-----------------------------------------------------------------------------------------------

'PublicP_
Public Sub exeProc()
    Call ctrProc
End Sub

'CtrlP_
Private Sub ctrProc()
    Call initializeOutputVariables
    Call initializeModuleVariables
'    Debug.Print "PassFlag: " & meMstrMdlName & "1"     'PassFlag
    
'//テキストファイルを開かずにデータを読み込み
    Call instCRdTxtNoOpn
    If myXlonRowCnt <= 0 Or myXlonColCnt <= 0 Then GoTo ExitPath
'    Debug.Print "PassFlag: " & meMstrMdlName & "2"     'PassFlag

'//2次元配列で文字列を検索して数値データの最初のデータ位置を取得
  Dim myXlonSrchRow As Long, myXlonSrchCol As Long
    Call PfixHVMatchString(myXlonSrchRow, myXlonSrchCol, _
            myXstrIfCndtn, myZstrOrgData, myXbisInStrOptn)
'    Debug.Print "PassFlag: " & meMstrMdlName & "3"     'PassFlag

  Dim L1 As Long, U1 As Long, L2 As Long, U2 As Long
    L1 = LBound(myZstrOrgData, 1): U1 = UBound(myZstrOrgData, 1)
    L2 = LBound(myZstrOrgData, 2): U2 = UBound(myZstrOrgData, 2)

'//取得する第一行と第一列を設定
  Dim myXlonNumBgnRow As Long, myXlonNumBgnCol As Long
    If myXlonSrchRow < L1 Then
        myXlonNumBgnRow = L1
    Else
        myXlonNumBgnRow = myXlonSrchRow + myXlonOfstRows
        If myXlonNumBgnRow < L1 Then myXlonNumBgnRow = L1
    End If
    If myXlonSrchCol < L2 Then
        myXlonNumBgnCol = L2
    Else
        myXlonNumBgnCol = myXlonSrchCol + myXlonOfstCols
        If myXlonNumBgnCol < L2 Then myXlonNumBgnCol = L2
    End If

'//数値データを取得する範囲を設定
  Dim myXlonNumEndRow As Long, myXlonNumEndCol As Long
    myXlonNumEndRow = myXlonNumBgnRow + myXlonNumRows - 1
    myXlonNumEndCol = myXlonNumBgnCol + myXlonNumCols - 1
    If myXlonNumEndRow > U1 Or myXlonNumEndRow < myXlonNumBgnRow Then _
        myXlonNumEndRow = U1
    If myXlonNumEndCol > U2 Or myXlonNumEndCol < myXlonNumBgnCol Then _
        myXlonNumEndCol = U2
    
'//2次元配列から数値データ範囲のデータ配列を取得
    myXlonNumRowCnt = myXlonNumEndRow - myXlonNumBgnRow + 1
    myXlonNumColCnt = myXlonNumEndCol - myXlonNumBgnCol + 1
    ReDim myZdouNumData(myXlonNumRowCnt, myXlonNumColCnt) As Double
    
  Dim i As Long, j As Long, m As Long, n As Long: m = 0: n = 0
    On Error Resume Next
    For j = myXlonNumBgnCol To myXlonNumEndCol
        n = n + 1
        m = 0
        For i = myXlonNumBgnRow To myXlonNumEndRow
            m = m + 1
            myZdouNumData(m, n) = CDbl(myZstrOrgData(i, j))
        Next i
    Next j
    On Error GoTo 0
    If m <> myXlonNumRowCnt Or n <> myXlonNumColCnt Then GoTo ExitPath
'    Debug.Print "PassFlag: " & meMstrMdlName & "4"     'PassFlag

'//ヘッダー内容を取得
  Dim myXlonSpltRow As Long: myXlonSpltRow = myXlonNumBgnRow
  Dim myXlonDwnRowCnt As Long, myZstrDwn() As String
    Call PfixArrayRowSplitString( _
            myXstrHdrRowCnt, myZstrHdr, myXlonDwnRowCnt, myZstrDwn, _
            myZstrOrgData, myXlonSpltRow)
    If myXstrHdrRowCnt > 0 Then myXstrHdrColCnt = myXlonColCnt
    Erase myZstrDwn
'    Debug.Print "PassFlag: " & meMstrMdlName & "5"     'PassFlag
    
    myXbisCmpltFlag = True
ExitPath:
    Call initializeModuleVariables
End Sub

'===============================================================================================

'クラス内Ｐ_ファイルを開かずにテキストファイルの内容を取得する
Private Sub instCRdTxtNoOpn()
  Dim myZlonTmp(1) As Long, L As Long: L = LBound(myZlonTmp)
  Dim i As Long, j As Long
  Dim myXinsRdTxtNoOpn As CRdTxtNoOpn: Set myXinsRdTxtNoOpn = New CRdTxtNoOpn
    With myXinsRdTxtNoOpn
    '//クラス内変数への入力
        .letFilePath = myXstrFilePath
        .letRdBgnEnd(1) = myXlonBgn
        .letRdBgnEnd(2) = myXlonEnd
        .letSpltOptn = myXbisSpltOptn
        .letSpltChr = myXstrSpltChr
    '//クラス内プロシージャの実行とクラス内変数からの出力
        .exeProc
        myXlonRowCnt = .getTxtRowCnt
        myXlonColCnt = .getTxtColCnt
        If myXlonRowCnt <= 0 Or myXlonColCnt <= 0 Then GoTo JumpPath
        i = myXlonRowCnt - (1 - L): j = myXlonColCnt - (1 - L)
        ReDim myZstrOrgData(i, j) As String
        For i = 1 To myXlonRowCnt
            For j = 1 To myXlonColCnt
                myZstrOrgData(i - (1 - L), j - (1 - L)) = .getTxtDataAry(i, j)
            Next j
        Next i
    End With
JumpPath:
    Set myXinsRdTxtNoOpn = Nothing
End Sub

'===============================================================================================

 '定型Ｐ_2次元配列で文字列を検索して最初のデータ位置を取得する
Private Sub PfixHVMatchString(myXlonRow As Long, myXlonCol As Long, _
            ByVal myXstrIfCndtn As String, ByRef myZstrOrgData() As String, _
            Optional ByVal coXbisInStrOptn As Boolean = False)
'myZstrOrgData(i, j) : 元データ配列
'coXbisInStrOptn = False : 指定文字列と一致する条件
'coXbisInStrOptn = True  : 指定文字列とを含む条件
    myXlonRow = Empty: myXlonCol = Empty
    If myXstrIfCndtn = "" Then Exit Sub
  Dim myXstrTmp As String, L As Long
    On Error GoTo ExitPath
    L = LBound(myZstrOrgData, 1): myXstrTmp = myZstrOrgData(L, L)
    On Error GoTo 0
  Dim i As Long, j As Long, r As Long, c As Long: r = L - 1: c = L - 1
    If coXbisInStrOptn = True Then
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            For i = LBound(myZstrOrgData, 1) To UBound(myZstrOrgData, 1)
                myXstrTmp = myZstrOrgData(i, j)
                If InStr(myXstrTmp, myXstrIfCndtn) > 0 Then
                    r = i: c = j: GoTo JumpPath
                End If
            Next i
        Next j
    Else
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            For i = LBound(myZstrOrgData, 1) To UBound(myZstrOrgData, 1)
                myXstrTmp = myZstrOrgData(i, j)
                If myXstrTmp = myXstrIfCndtn Then
                    r = i: c = j: GoTo JumpPath
                End If
            Next i
        Next j
    End If
JumpPath:
    myXlonRow = r: myXlonCol = c
ExitPath:
End Sub

 '定型Ｐ_2次元配列を指定行で2個の配列に分割する
Private Sub PfixArrayRowSplitString( _
            myXlonUpRowCnt As Long, myZstrUp() As String, _
            myXlonDwnRowCnt As Long, myZstrDwn() As String, _
            ByRef myZstrOrgData() As String, ByVal myXlonSpltRow As Long)
'myZstrUp(i, j)  : 分割後の上側データ配列
'myZstrDwn(i, j) : 分割後の下側データ配列
'myZstrOrgData(i, j) : 元データ配列
'myXlonSpltRow : 分割する行番号を指定(指定行以下を分割)
    myXlonUpRowCnt = Empty: Erase myZstrUp
    myXlonDwnRowCnt = Empty: Erase myZstrDwn
  Dim myXstrTmp As String, L As Long
    On Error GoTo ExitPath
    L = LBound(myZstrOrgData, 1): myXstrTmp = myZstrOrgData(L, L)
    On Error GoTo 0
    If myXlonSpltRow < LBound(myZstrOrgData, 1) + 1 _
        Or myXlonSpltRow > UBound(myZstrOrgData, 1) Then Exit Sub
  Dim i As Long, j As Long, m As Long, n As Long: m = L - 1: n = L - 1
    myXlonUpRowCnt = myXlonSpltRow - LBound(myZstrOrgData, 1)
    myXlonDwnRowCnt = UBound(myZstrOrgData, 1) - myXlonSpltRow + 1
    j = UBound(myZstrOrgData, 2)
    i = myXlonUpRowCnt - (1 - L): ReDim myZstrUp(i, j) As String
    i = myXlonDwnRowCnt - (1 - L): ReDim myZstrDwn(i, j) As String
    For i = LBound(myZstrOrgData, 1) To myXlonSpltRow - 1
        m = m + 1
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            myZstrUp(m, j) = myZstrOrgData(i, j)
        Next j
    Next i
    For i = myXlonSpltRow To UBound(myZstrOrgData, 1)
        n = n + 1
        For j = LBound(myZstrOrgData, 2) To UBound(myZstrOrgData, 2)
            myZstrDwn(n, j) = myZstrOrgData(i, j)
        Next j
    Next i
ExitPath:
End Sub

'DummyＰ_
Private Sub CsubDummy()
End Sub

'===============================================================================================

''◆ClassProc名_テキストファイル内から数値データ配列を取得する
'Private Sub instCTxtFileNumAry()
'  Dim Lc As Long
'  Dim myXbisCmpltFlag As Boolean
'  Dim myXlonNumRowCnt As Long, myXlonNumColCnt As Long, myZdouNumData() As Double
'  Dim myXstrHdrRowCnt As Long, myXstrHdrColCnt As Long, myZstrHdr() As String
''//クラス内変数への入力
'  Dim myXstrFilePath As String
'  Dim myXlonBgn As Long, myXlonEnd As Long
'  Dim myXbisSpltOptn As Boolean, myXstrSpltChr As String
'    'myXbisSpltOptn = True  : 文字列を分割処理する
'    'myXbisSpltOptn = False : 文字列を分割処理しない
'    myXstrFilePath = "C:\_Cdrive\x01_検討中\テスト用データファイル\test2.csv"
'    myXlonBgn = 1
'    myXlonEnd = 0
'    myXbisSpltOptn = True
'    myXstrSpltChr = ""
'  Dim myXstrIfCndtn As String
'    'myXstrIfCndtn : 数値データの最初のデータ位置の検索条件
'  Dim myXbisInStrOptn As Boolean
'    'myXbisInStrOptn = False : 指定文字列と一致する条件で検索する
'    'myXbisInStrOptn = True  : 指定文字列を含む条件で検索する
'  Dim myXlonOfstRows As Long, myXlonOfstCols As Long
'    'myXlonOfstRows : 検索位置から数値データの最初のデータ位置のオフセット行数
'    'myXlonOfstCols : 検索位置から数値データの最初のデータ位置のオフセット列数
'    myXstrIfCndtn = "No"
'    myXbisInStrOptn = False
'    myXlonOfstRows = 1
'    myXlonOfstCols = 0
'  Dim myXlonNumRows As Long, myXlonNumCols As Long
'    'myXlonNumRows : 数値データの取得行数
'    'myXlonNumCols : 数値データの取得列数
'    myXlonNumRows = 10
'    myXlonNumCols = 1
''//CTxtFileNumAryクラスモジュールのインスタンス生成
'  Dim myZlonTmp(1) As Long, Lo As Long: Lo = LBound(myZlonTmp)
'  Dim i As Long, j As Long
'  Dim myXinsTxtFileNumAry As CTxtFileNumAry: Set myXinsTxtFileNumAry = New CTxtFileNumAry
'    With myXinsTxtFileNumAry
'    '//クラス内変数への入力
'        .letFilePath = myXstrFilePath
'        .letRdBgnEnd(1) = myXlonBgn
'        .letRdBgnEnd(2) = myXlonEnd
'        .letSpltOptn = myXbisSpltOptn
'        .letSpltChr = myXstrSpltChr
'        .letIfCndtn = myXstrIfCndtn
'        .letInStrOptn = myXbisInStrOptn
'        .letOfstRows = myXlonOfstRows
'        .letOfstCols = myXlonOfstCols
'        .letNumRows = myXlonNumRows
'        .letNumCols = myXlonNumCols
'    '//クラス内プロシージャの実行とクラス内変数からの出力
'        .exeProc
'        myXbisCmpltFlag = .getCmpltFlag
'        myXlonNumRowCnt = .getNumRowCnt
'        myXlonNumColCnt = .getNumColCnt
'        If myXlonNumRowCnt <= 0 Or myXlonNumColCnt <= 0 Then GoTo JumpPath
'        i = myXlonNumRowCnt + Lo - 1: j = myXlonNumColCnt + Lo - 1
'        ReDim myZdouNumData(i, j) As Double
'        Lc = .getOptnBase
'        For j = 1 To myXlonNumColCnt
'            For i = 1 To myXlonNumRowCnt
'                myZdouNumData(i + Lo - 1, j + Lo - 1) = .getNumDataAry(i + Lc - 1, j + Lc - 1)
'            Next i
'        Next j
'        myXstrHdrRowCnt = .getHdrRowCnt
'        myXstrHdrColCnt = .getHdrColCnt
'        If myXstrHdrRowCnt <= 0 Or myXstrHdrColCnt <= 0 Then GoTo JumpPath
'        i = myXstrHdrRowCnt + Lo - 1: j = myXstrHdrColCnt + Lo - 1
'        ReDim myZstrHdr(i, j) As String
'        For j = 1 To myXstrHdrColCnt
'            For i = 1 To myXstrHdrRowCnt
'                myZstrHdr(i + Lo - 1, j + Lo - 1) = .getHdrAry(i + Lc - 1, j + Lc - 1)
'            Next i
'        Next j
'    End With
'JumpPath:
'    Set myXinsTxtFileNumAry = Nothing
''    Call variablesOfCTxtFileNumAry(myXlonNumRowCnt, myZdouNumData)  'Debug.Print
'ExitPath:
'End Sub
'Private Sub variablesOfCTxtFileNumAry( _
'            ByVal myXlonDataCnt As Long, ByRef myZvarField As Variant)
''//CTxtFileNumAryクラス内から出力した変数の内容確認
'    Debug.Print "データ数: " & myXlonDataCnt
'    If myXlonDataCnt <= 0 Then Exit Sub
'  Dim i As Long, j As Long
'    For i = LBound(myZvarField, 1) To UBound(myZvarField, 1)
'        For j = LBound(myZvarField, 2) To UBound(myZvarField, 2)
'            Debug.Print "データ" & i & "," & j & ": " & myZvarField(i, j)
'        Next j
'    Next i
'End Sub
